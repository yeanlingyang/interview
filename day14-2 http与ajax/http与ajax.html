<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>

<body>
  <script>
    // ============================================= 服务器与客户端 ===================================================================


    /*服务器的作用      提供服务的机器   （被索取服务的机器，也叫处理请求，并且响应请求对象）
                      详细解释 服务器（英文名称server），也称伺服器。指一个管理资源并为用户提供服务的计算机设备。
                      由于服务器需要响应服务请求，并进行处理，因此一般来说服务器应具备承担服务并且保障服务的能力 
      */
    /*  客户端          索取服务的对象 （发送请求的对象）
                        客户端（Client）或称为用户端，是指与服务器相对应，为客户提供本地服务的程序
     */

    // =========================================== 请求和响应组成 =====================================================================

    // 服务器与客服端的交互是怎么进行的 （客户端发送请求,服务器响应） ==>> http协议

    //HTTP协议全名(超文本传输协议)。是一种详细规定了浏览器和服务器之间互相通信的规则

    /* 重点：HTTP协议由请求和响应两个部分构成
    

    （1）请求结构 ：请求行 请求头 请求体构成    （get没有请求体，浏览器默认设置，参数拼接在地址栏中） 
    （2）响应结构： 状态行 响应头 响应体构成 
    */
    // ================================================== 请求的方式 =========================================================
    // 1、 link标签的href属性

    // 2、 script标签的src属性

    // 3、 img标签的src属性

    // 4、 ajax发送请求

    // 5、 表单提交发送请求

    // 6、 a标签的href发送请求

    // 7、 iframe的src属性发送请求  用来在行内引入框架（知道有这玩意就可以，不然吹牛2年经验会打脸）


    //  请求分为普通请求(httpRequest)和ajax请求（XMLHttpRequest） 
    //  普通请求需要刷新才能更新  ajax请求不用 前端之所以火 ajax是功臣之一

    //  在http协议中 有get/post/put/delete 等共支持7种方法 这7中请求方法中大部分是资源请求，
    //   资源型的请求不受同源策略限制。 json

    //  其中以post和get方法使用最常见(ajax提供的)，但初代的ajax受同源策略的影响
    //  jQuery里封装好的ajax能用jsonp只是提供了这个方法，但与ajax没有关系,jsonp是利用script标签进行跨域的
    
    // ========================================================== ajax前端吃饭的看家本领 ==========================================================

    /*    Ajax = 异步 JavaScript 和 XML 或者是 HTML（标准通用标记语言的子集）。   ajax+html/xml+js
          Ajax 是一种用于创建快速动态网页的技术。
          Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术
          // 发展历史 ====> https://blog.csdn.net/z550449054/article/details/80538623
     */

    //  将一个页面动态的渲染是前端最基本的功夫 鹏鹏老师说过在外面只会写静态网页叫 ==> 切图仔   所以我们不要当切图仔


    // ajax数据交互的方式  三大明显可见区别  请求行（参数有无）   请求头（content-type 有无）  请求体（内容有无）

    /* 1. get方式
        数据会拼接在url地址的后面，例如?username=hcc&password=123456 在请求行中    //粗暴
        地址栏有长度限制，因此get方式提交数据大小不会超过4k                         //话不敢多 多有可能会被打死 
        但是： get请求传递速度快 所以一些不是重要且数据不是太大的的信息都是用get请求
        （接口调用基本都是get）                                                   // 唯一的好处 要的快 当然也可能死的快
        
        2. post方式
        数据不会在url中显示，相比get方式，post更安全                               //隐蔽  打电话
        提交的数据没有大小限制                                                     // （没说 所以没有太多要求）
        */
    //  重点：根据HTTP规范，GET用于信息获取，POST表示可能修改变服务器上的资源的请求 删除添加信息等操作


    // ====================================================== 原生初代 ajax 解析 ================================================
    //xhr是对象,也就是ajax功能实现所依赖的对象,提供了对 HTTP 协议的完全的访问，包括做出 POST 以及普通的 GET 请求的能力

    var xhr = new XMLHttpRequest();

    console.log(xhr);

    xhr.open('post/get', 'url'); //get参数拼接在url后面   这一行设置请求行

    xhr.setRequestHeader('content-type', '文件类型') //这一行设置请求体
    //get不用指定,系统默认设置  原因GET请求不存在请求实体部分，键值对参数放置在 URL 尾部，且是由浏览器执行的

    /*  post设置原因：首先，HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记，
         Content-Type 被指定为 application/x-www-form-urlencoded提交的数据是按照 key1=val1&key2=val2
          的方式进行编码，key 和 val 都进行了 URL 转码。大部分服务端语言都对这种方式有很好的支持。
    */
    //详情可查 四种常见的 POST 提交数据方式对应的content-type取值 https://www.cnblogs.com/wushifeng/p/6707248.html



    xhr.send('参数/null'); //get没有请求体 默认为null 
    //post请求 参数拼接方式  1. 手动   2. 2.0 formData对象   3. jq中data属性中 可以传对象或者用$("form").serialize();



    //  GET请求没有请求体，因为GET请求的参数拼接到地址栏中了    太直接了 人狠话不多
    //  POST请求有请求体，就是传递的参数                      委婉 耐听 （班里某些人说话超级有趣，就喜欢和他讲话） 
    //  POST请求需要指定content-type属性。   


    // =====================================================响应报文===============================================================


    // 不管对于post请求还是get请求 服务器对于回复的响应报文结构都是一样的 
    // 响应报文结构 ：状态行  响应头 响应体
    // 状态码 ； 200成功 302重定向 304缓存  404没找到 5xx开头服务器错误 ==>后端可以设置res.statusCode 来根据不同情况响应不同状态码

    //给xhr注册一个onreadystatechange事件，当xhr的状态发生状态发生改变时，会触发这个事件。
    xhr.onreadystatechange = function () {
      console.log(xhr.status); //打印状态码            在node中 可以根据res。statusCode来设置不同情况下的状态码
      if (xhr.readyState == 4 && xhr.status === 200) {
        //1. 获取状态行
        //2. 获取响应头
        console.log("所有的响应头信息:" + xhr.getAllResponseHeaders());
        console.log("指定响应头信息:" + xhr.getResponseHeader("content-type"));
        //3. 获取响应体内容
        console.log(xhr.responseText);
      }
    }
    // xhr.readyState
    //0：请求未初始化。
    //1：请求已经建立，但是还没有开始发送。
    //2：请求已发送，正在处理中
    //3：请求在处理中；通常响应中已有部分数据可用了，但是服务器还没有完成响应的生成。 请求处理中指的是在 
    //4：响应已完成；您可以获取并使用服务器的响应了。(我们只需要关注状态4即可)




    // -------------------------------------------------

    // 拓展  三次握手和四次分手协议

    /*   HTTP总是Client端来发起请求。

1、客户机（浏览器）主动向服务器（web   server)发出连接请求。 

2、服务器接受连接请求并建立起连接。 (1,2步就是 TCP三次握手)       
                                                                              
3、客户机通过此连接向服务器发出GET等http命令，(“HTTP请求报文”)。

4、服务器接到命令并根据命令向客户机传送相应的数据，(“HTTP响应报文”)。

5、客户机接收从服务器送过来的数据。

6、服务器发送完数据后，主动关闭此次连接。 （”TCP四次分手“）


概况起来就是 客户/服务器传输过程可分为四个基本步骤：

  1) 浏览器与服务器建立连接； (TCP三次握手)

  2) 浏览器向服务器请求文档；

  3) 服务器响应浏览器请求；

  4) 断开连接。（”TCP四次分手“） */







    // tcp三次握手协议
    /* 
    第一步  发出请求（SYN标志的TCP报文）请求连接服务器 并准备   报文内含有（要连接的ip地址 端口 域名 等等详细数据） 
    第二步 服务器收到同步请求后发出请求应答（带ACK标志和SYN标志的报文），同时准备好端口，ip等资源 并将这些资源加入等待连接状态
    第三部 客户端接收到服务器发送的报文后，再次回应服务段一个ACK报文    
     验证通过后 服务器与客户端进行连接 



     类似申请出国  先报备申请取哪个国家（写申请书，并签名）==>
     官方确认并告知通过条件和时间（盖章并发送须知事项）===>回复有这个条件（签字，达成协议）
     */

    // tcp四次分手协议
    /* 
    1.服务器接收到最后一个数据包后，客户端接着发送一个数据包，告诉服务器 数据发送完成 准备断开；
    2.服务接收到后告诉客户端说，你等下 我看看还有有没事情要跟你交代的。
    2.服务器在确认没有要交代的 就发个消息说我也说完了，没啥说的了，可以断开了；
    4.客户端回应：收到，那我断开了。   客户端断开连接，服务器对资源进行回收
    */

    // 友情连接地址 https://blog.csdn.net/scuzoutao/article/details/81774100
    //             https://blog.csdn.net/A_fool_Program_ape/article/details/81748544
  </script>
</body>

</html>