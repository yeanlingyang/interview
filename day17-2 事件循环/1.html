<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<title>Document</title>
</head>

<body>
	<script>
		/* 第一题 */
		// for(var i = 0;i<5;i++){
		// 	console.log(i);
		// }		//  0 1 2 3 4
	


		/* 第二题 */
		//延时器是异步事件
		// for(var i = 0;i<5;i++){
		// 	setTimeout(function(){
		// 		console.log(i);
		// 	},1000*i);
		// } //5  打印5次

		// 在for循环中使用 var 声明变量是全局变量，当for循环执行完毕，此时的 i 是5。
		// 再经过一秒钟后分别调用setTimeout函数，输出的 i 都是全局作用域中的 i ，即5。




		/* 第三题 */
		//怎么改才能输出0-4
		// 闭包
		for(var i = 0;i<5;i++){
			(function(i){
				setTimeout(function(){
					console.log(i);
				},i*1000);
			})(i);
		}   //01234
		// 如果把i去掉的话  打印的还是5个5，里面没有形参  所以还是打印5个5

		


		// for (let i = 0; i < 5; i++) {
		// 	setTimeout(() => {
		// 		console.log(i);
		// 	}, 1000);
		// }     //01234
		// let 关键字使每一次for循环中都有一个独立作用域中的 i ，互不干扰，所以输出的都是各自作用域中的 i，而不是全局作用域中的 i








		/* 第四题 */
		//setTimeout可以接受函数或者字符串作为参数，而给setTimeout传递了一个立即执行函数，该立即执行函数是undefined ，延时器就失效了
		// 也就是说等价于setTimeout(undefined, ...)。立即执行函数会立即执行。（类似第一题）
		// for(var i = 0;i<5;i++){
		// 	setTimeout((function(i){
		// 		console.log(i);
		// 	})(i),i*1000);
		// } //01234



		/* 知识点补充 */
		// setTimeout(code, milliseconds, param1, param2, ...)
		// setTimeout(function, milliseconds, param1, param2, ...)
		//code/function:必需。要调用一个代码串，也可以是一个函数。
		// milliseconds:可选。执行或调用 code/function 需要等待的时间，以毫秒计。默认为 0。
		// param1, param2, ... : 可选。 传给执行函数的其他参数（IE9 及其更早版本不支持该参数）。

		// for(var i = 0;i<5;i++){setTimeout('console.log(i);	',i*1000);}





		/* 拓展 */
		//用到了promise，感兴趣的人可以去深入了解，拓展一下自己
		// setTimeout(function () {
		// 	console.log(1)
		// }, 0);
		// new Promise(function executor(resolve) {
		// 	console.log(2);
		// 	for (var i = 0; i < 10000; i++) {
		// 		i == 9999 && resolve();
		// 	}
		// 	console.log(3);
		// }).then(function () {
		// 	console.log(4);
		// });
		// console.log(5);


	</script>
</body>

</html>